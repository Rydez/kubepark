# Grafana Alloy Helm Chart Values
# This replaces the manual alloy.yaml deployment with the official Helm chart

# Deploy as DaemonSet to collect logs from all nodes
controller:
  type: "daemonset"

# Service account configuration
serviceAccount:
  create: true
  name: "alloy"

# Namespace configuration
namespace: "alloy"

# Alloy configuration
alloy:
  configMap:
    content: |
      // Grafana Alloy configuration for KubePark log collection
      logging {
        level = "debug"
        format = "logfmt"
      }

      prometheus.remote_write "default" {
        endpoint {
          url = "http://host.docker.internal:9090/api/v1/write"
        }
      }

      loki.write "default" {
        endpoint {
          url = "http://host.docker.internal:3100/loki/api/v1/push"
        }
      }

      discovery.kubernetes "pods" {
        role = "pod"

        namespaces {
          own_namespace = false
          names         = ["kube-state-metrics", "park", "guests", "attractions"]
        }
      }

      // discovery.relabel rewrites the label set of the input targets by applying one or more relabeling rules.
      // If no rules are defined, then the input targets are exported as-is.
      discovery.relabel "pods" {
        targets = discovery.kubernetes.pods.targets

        // Label creation - "namespace" field from "__meta_kubernetes_namespace"
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          action = "replace"
          target_label = "namespace"
        }

        // Label creation - "pod" field from "__meta_kubernetes_pod_name"
        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          action = "replace"
          target_label = "pod"
        }

        // Label creation - "container" field from "__meta_kubernetes_pod_container_name"
        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "container"
        }

        // Label creation -  "app" field from "__meta_kubernetes_pod_label_app_kubernetes_io_name"
        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
          action = "replace"
          target_label = "app"
        }

        // Label creation -  "job" field from "__meta_kubernetes_namespace" and "__meta_kubernetes_pod_container_name"
        // Concatenate values __meta_kubernetes_namespace/__meta_kubernetes_pod_container_name
        rule {
          source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "job"
          separator = "/"
          replacement = "$1"
        }

        // Label creation - "container" field from "__meta_kubernetes_pod_uid" and "__meta_kubernetes_pod_container_name"
        // Concatenate values __meta_kubernetes_pod_uid/__meta_kubernetes_pod_container_name.log
        rule {
          source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "__path__"
          separator = "/"
          replacement = "/var/log/pods/*$1/*.log"
        }

        // Label creation -  "container_runtime" field from "__meta_kubernetes_pod_container_id"
        rule {
          source_labels = ["__meta_kubernetes_pod_container_id"]
          action = "replace"
          target_label = "container_runtime"
          regex = "^(\\S+):\\/\\/.+$"
          replacement = "$1"
        }
      }

      prometheus.scrape "pods" {
        targets    = discovery.relabel.pods.output
        forward_to = [prometheus.remote_write.default.receiver]
      }

      loki.source.kubernetes "pods" {
        targets    = discovery.relabel.pods.output
        forward_to = [loki.write.default.receiver]
      }

# Container configuration
image:
  registry: "docker.io"
  repository: "grafana/alloy"
  tag: "latest"

# Resource limits and requests
resources:
  limits:
    memory: "512Mi"
    cpu: "500m"
  requests:
    memory: "256Mi"
    cpu: "100m"

# Security context
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false

# Volume mounts for log collection
volumes:
  - name: varlog
    hostPath:
      path: /var/log
  - name: varlibdockercontainers
    hostPath:
      path: /var/lib/docker/containers

volumeMounts:
  - name: varlog
    mountPath: /var/log
    readOnly: true
  - name: varlibdockercontainers
    mountPath: /var/lib/docker/containers
    readOnly: true

# Tolerations for running on control plane nodes
tolerations:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
    operator: Exists
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
    operator: Exists

# RBAC permissions
rbac:
  create: true

# Service configuration
service:
  enabled: true
  type: ClusterIP
  port: 12345

# Health checks
readinessProbe:
  enabled: true
  httpGet:
    path: /-/ready
    port: http-metrics
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 1
  failureThreshold: 5
  successThreshold: 1

# Environment variables
env:
  - name: HOSTNAME
    valueFrom:
      fieldRef:
        fieldPath: spec.nodeName
